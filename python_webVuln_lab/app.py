from flask import Flask, request, render_template_string, render_template
import highlight_code
import jinja2, re, hashlib
import mysql.connector
import hashlib

app = Flask(__name__)
app.secret_key = b'SECRET_KEY'

# MySQL configuration
db_config = {
    'host': 'localhost',
    'port': 3306,
    'user': 'root',
    'password': 'S01257595153',
    'database': 'training'
}
# Create a MySQL connection
connection = mysql.connector.connect(**db_config)

def hash_password(password):
    return hashlib.md5(password.encode()).hexdigest()
# Routing to Index Page
@app.route('/', methods=['GET'])
def index():
    return render_template('index.html')

# Routing to SSTI lab
@app.route('/ssti', methods=['GET', 'POST'])
def ssti():
    name = request.form.get('name', '')
    
    if request.method == 'POST':
        # Handle the form submission
        content = render_template_string('Hello ' + name + '!')
        return render_template('ssti.html', content=content, highlighted_code=highlight_code.ssti())
    
    # Render the form
    if request.method == 'GET':
        return render_template('ssti.html', highlighted_code=highlight_code.ssti())
    
# Routing to Boolean-based SQLi Lab (Login page 1)
@app.route('/bool_sqli', methods=['GET', 'POST'])
def boolean_sqli():
    if request.method == 'GET':
        return render_template('login.html', highlighted_code=highlight_code.bool_sqli())
    if request.method == 'POST':
        try:
            email = request.form['email']
            passwordHash = hash_password(request.form['password'])

            cursor = connection.cursor(buffered=True)

            # Execute a simple SQL query with user input (vulnerable to SQL injection)
            query = "SELECT * FROM users WHERE email='" + email + "' AND passwordHash='" + passwordHash + "'"
            cursor.execute(query)
            user = cursor.fetchone()
            
            if user:
                return render_template('login.html', notification='Login successfully!', highlighted_code=highlight_code.bool_sqli())
            else:
                return render_template('login.html', notification='Login failed!', highlighted_code=highlight_code.bool_sqli())
        except Exception:
            return render_template('login.html', notification='Login failed!', highlighted_code=highlight_code.bool_sqli())

# Routing to Error-based SQLi Lab (Login page 2)
@app.route('/err_sqli', methods=['GET', 'POST'])
def err_sqli():
    if request.method == 'GET':
        return render_template('err_login.html', highlighted_code=highlight_code.err_sqli())
    if request.method == 'POST':
        try:
            email = request.form['email']
            passwordHash = hash_password(request.form['password'])

            # Create a MySQL connection
            connection = mysql.connector.connect(**db_config)
            cursor = connection.cursor(buffered=True)

            # Execute a simple SQL query with user input (vulnerable to SQL injection)
            query = "SELECT * FROM users WHERE email='" + email + "' AND passwordHash='" + passwordHash + "'"
            cursor.execute(query)
            user = cursor.fetchone()
            if user:
                return render_template('err_login.html', notification='Login successfully!', highlighted_code=highlight_code.err_sqli())
            else:
                return render_template('err_login.html', notification='Login failed!', highlighted_code=highlight_code.err_sqli())
        except Exception as e:
            return render_template('err_login.html', notification=e, highlighted_code=highlight_code.err_sqli())

# Routing to Time-based SQLi Lab (Feedback Page)
@app.route('/time_sqli', methods=['GET', 'POST'])
def time_sqli():
    try:
        if request.method == 'POST':
            email = request.form['email']
            message = request.form['message']

            # Create a MySQL connection
            connection = mysql.connector.connect(**db_config)
            cursor = connection.cursor()

            # Execute an query to add a feedback to the DB
            query = f"INSERT INTO feedback (email, message) VALUES ('{email}', '{message}')"
            cursor.execute(query)

            return render_template('feedback.html', notification='Message sent successfully!', highlighted_code=highlight_code.time_sqli())
        return render_template('feedback.html', highlighted_code=highlight_code.time_sqli())
    except Exception:
        return render_template('feedback.html', notification='Message sent successfully!', highlighted_code=highlight_code.time_sqli())

# Routing to UNION-Based SQLi Lab (Find User Page)
@app.route('/union_sqli', methods=['GET','POST'])
def union_sqli():
    try:
        if request.method == 'POST':
            keyword = request.form['keyword']
            
            # Create a MySQL connection
            connection = mysql.connector.connect(**db_config)
            cursor = connection.cursor(dictionary=True)
            
            # Execute a search query based on user input
            query = f"SELECT * FROM users WHERE fullname LIKE '%{keyword}%'"
            cursor.execute(query)
            results = cursor.fetchall()
            
            return render_template('search_user.html', results=results, highlighted_code=highlight_code.union_sqli())
        return render_template('search_user.html', highlighted_code=highlight_code.union_sqli())
    except Exception:
        return  render_template('search_user.html', notification='An error occured', highlighted_code=highlight_code.union_sqli())

# Routing to Reflected XSS Lab
@app.route('/reflected_xss', methods=['GET'])
def reflected_xss():
    name = request.args.get('name')
    return render_template('reflected_xss.html', name=name)

# Routing to Stored XSS Lab
@app.route('/stored_xss', methods=['GET','POST'])
def stored_xss():
    try:
        if request.method == 'POST':
            comment = request.form.get('comment')

            # Store the comment in the database (with prepared statement)
            cursor = connection.cursor()
            cursor.execute("INSERT INTO comments (content) VALUES (%s)", (comment,))
            connection.commit()
        
        # Retrieve comments from the database and display them
        cursor = connection.cursor()
        cursor.execute("SELECT * FROM comments")
        comments = cursor.fetchall()
    except Exception:
        return render_template('comments.html')
    return render_template('comments.html', comments=comments)      

# Routing to DOM-based XSS Lab
@app.route('/dom_xss', methods=['GET', 'POST'])
def dom_xss():
    if request.method == 'POST':
        return render_template('dom_xss.html', notification='Selected successfully!')
    return render_template('dom_xss.html')

if __name__ == '__main__':
        app.run(host='0.0.0.0', port=8001, debug=False)
